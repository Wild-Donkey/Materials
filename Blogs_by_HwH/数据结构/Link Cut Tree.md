# Link Cut Tree

## 树链剖分

### 轻重链剖分

轻重链剖分即将一棵树按照子树的大小分为轻儿子和重儿子，完全由重儿子组成的一条路径就是一条重链，其余的树链则构成轻链

每一个节点对应着都有一条重链，而轻链没有数量限制

这种树链剖分的方式需要提前进行预处理，利用线段树或者树状数组进行维护

### 实链剖分

对于一棵树，将某一个儿子的连边划分为实链，而其他节点所连的边为虚链

对于这种树链剖分的方式，可以使用 $Splay$ 进行动态的维护

* 性质：
  
  1. 每一颗 $Splay$ 在树中维护的都是一条从上到下深度对应在原树中严格递增的路径，且中序遍历得到的 $Splay$ 的每个点的深度序列严格递增
   
  2. 每个节点被包含且仅被包含在一个 $Splay$ 中
   
  3. 实链一定被包含在 $Splay$ 中，而虚边由一棵 $Splay$ 连向另一个节点，且该节点为该 $Splay$ 中序遍历中最靠前的点的父节点，同时，一个点只能子节点中的一个连实链，所以不能直接在 $Splay$ 上从该点访问其子节点

### 长链剖分

和轻重链剖分相似，只需要将按照子树大小划分改为按照链的长度划分即可，最长的链即为长链，可以完成一些更优秀的统计

## 操作

### 预定义

```cpp
struct node
{
	ll fa,son[2]; // fa 记录该节点在 Splay 中对应的父节点，同理，son[] 对应着该节点在原树中的子节点
	ll v,sum; 
	ll tag; // 对于子树的调整标记，进行反转
	
	node()
	{
		fa=0;
		son[0]=son[1]=0;
		v=sum=tag=0;
	}
} tre[maxn];
```

### access

