# 字符串复习

## KMP

对于一个字符串 $S$，若字符串 $T$ 既是 $S$ 的前缀又是 $S$ 的后缀，则称 $T$ 是 $S$ 的公共前后缀，记作 $T \in \rm {border}(S)$。

显然对于任意一个字符串，遍历其最长 border，最长 border 的最长 border，……，一直操作下去直到空串就可以遍历该字符串的所有 border 了。

KMP 是用来求出字符串 $S$ 的每个前缀的最长 border 的。

设 $S_i$ 代表 $S$ 长度为 $i$ 的前缀。

假设目前已经确定了 $S_i$ 的最长 border 为 $S_j$，现在考虑求 $S_{i + 1}$ 的最长 border，只需要遍历 $S_i$ 的所有 border，找到最长的且下一个位置为 $S_{i + 1}$ 的最后一个字符的 border，那么该 border 加上最后一个字符显然就是 $S_{i  + 1}$ 的最长 border。而遍历 border 的方法即为不断跳最长 border 即可。

考虑 KMP 求出一个字符串的所有前缀的最长 border 的时间复杂度，注意到每次查询一个新前缀的答案时，所找到的最长 border 的长度最长增加 $1$，而遍历 border 的时候不会把长度变为负数，且每次长度至少减一，因此其复杂度是线性的。

注意到 KMP 的过程相当于把两个 $S$ 错一位以后进行匹配，匹配时考虑的是较短串是否等于较长串的后缀。因此 KMP 也可以用来求对于两串 $S,T$，$T$ 对于 $S$ 的每个前缀 $S_0$ 的最长前缀 $T_0$，使得 $S_0$ 的长度为 $|T_0|$ 的后缀与 $T_0$ 相等。

## Z-Algorithm

OI 里好像叫扩展 KMP？但这个东西和 KMP 好像没什么关系？

对于两串 $S, T$，可以用 Z-Algorithm 求出 $T$ 与 $S$ 的每个后缀的最长公共前缀。

考虑从前到后确定 $S$ 的每个后缀的答案。设目前已经确定了 $S_{i \sim n}$ 的答案 $ans_i$，要计算 $S_{i + 1 \sim n}$ 的答案 $ans_{i + 1}$。

设 $p$ 是 $1$ 到 $i$ 的整数，且 $ans_p + p$ 是最大的，记 $q = ans_p + p$。即 $q$ 是当前在 $S$ 中匹配到的最远位置，$p$ 是生成该位置的下标。

首先如果 $q \leq  i$，则暴力向后匹配即可。下面只考虑 $q > i$ 的情况。

对于该情况，一定在 $T$ 中可以找到一个位置 $j$，满足 $T_{1 \sim j} = S_{p \sim i}$。即 $j$ 是在 $p$ 处与 $i$ 对应的下标。设 $T_{j \sim n}$ 与 $T$ 的最长公共前缀为 $next_j$。分两种情况

1. $i + next_j < q$。此时 $T_{next_j + 1} \neq S_{i + next_j + 1}$，而 $next_j$ 及之前都是相等的，因此 $ans_i = next_j$。
2. $i + next_j \geq q$。此时从 $i$ 到 $q$ 都能匹配上，再往后的位置暴力匹配即可。

考虑时间复杂度，每进行一次暴力匹配，$q$ 都会增加 $1$，而 $q$ 不会超过串的长度，且剩下的操作都是 $O(1)$ 的，因此总时间复杂度是线性的。

而求 $next$ 相当于把 $T$ 错两位后进行匹配。注意要预处理 $next_1$ 和 $next_2$ 才能做，只预处理 $next_1$ 没有意义。

实现上其实不需要考虑 $q \leq i$ 的情况，因为在这种情况下求出来的 $i + next_j$ 一定大于 $q$，所以只需要分两种情况即可。

## Manacher

大概是用来求字符串以每个字符或两字符之间位置为对称轴的最长回文子串。

首先的操作是把原串相邻两字符之间加入一个相同的无关字符，并在最后加入另一个无关字符，这样保证了原串的所有回文子串的对称轴在新串上都是字符，最后的字符保证了匹配时不会匹配越界，即不会出现长度为无穷的回文串。

后面的操作类似 Z-Algorithm，从前往后扫描以新串每个字符为对称轴的回文子串，设 $q$ 是向右延伸最远的位置，$p$ 是延伸到该位置的对称轴下标。考虑求 $i$ 的答案。

首先当 $i \geq q$ 时暴力尝试拓展 $q$。

否则求出 $i$ 关于 $p$ 的对称点 $j$，如果 $j$ 对应的最长回文串的左端点关于 $p$ 的对称点小于 $q$，即 $j$ 对应的回文串被 $p$ 对应的大回文串完全包含且没有达到边界，根据回文串的对称性，显然 $ans_j = ans_i$。否则从 $i$ 到 $q$ 的位置一定属于回文串，然后暴力拓展 $q$ 即可。

考虑时间复杂度，同样 $q$ 的拓展是均摊 $O(1)$ 的，剩下的操作都是 $O(1)$ 的，因此总复杂度是线性的。

## SA

可以用来求出一个字符串的所有后缀的字典序排名。

考虑使用倍增法迭代排序，每次倍增后缀的有效位数，那么发现前一半的相对大小关系和后一半的相对大小关系都是确定的，也即进行一次双关键字排序即可。一共进行 $O(\log n)$ 次排序，因此总复杂度为 $O((n + T)\log n)$ ，其中 $T$ 是排序复杂度。用基数排序进行双关键字排序做到 $O(n \log n)$。

进行后缀排序后，定义数组 $height_i$ 为排名为 $i$ 的后缀与排名为 $i - 1$ 的后缀的最长公共前缀，$H_i = height_{rank_i}$，即 $H_i$ 是长度为 $(n - i + 1)$ 的后缀与其在后缀数组中前面一名的后缀的最长公共前缀，则 $H$ 满足 $H_i \geq H_{i - 1} - 1$。运用这个性质即可 $O(n)$ 递推出 height 数组。

height 数组最经典的性质是，考虑排名为 $i$ 的后缀 $sa_i$ 和排名为 $j$ 的后缀 $sa_j$（其中 $i < j$），则 $sa_i$ 和 $sa_j$ 的最长公共前缀为 $\min_{k = i + 1}^j height_k$。这个东西显然可以使用 ST 来做到 $O(n \log n) - O(1)$ 的时间复杂度与 $O(n \log n)$ 的空间复杂度，也可以使用线段树来做到 $O(n) - O(\log n)$ 的时间复杂度与 $O(n)$ 的空间复杂度。也就是说，有了后缀数组和 height，我们就可以用至多为对数级的时间复杂度来查询任意两个后缀的最长公共前缀了。

## ACAM

AC 自动机。对于一个自动机的定义是一个有向无环图，用来表示一个字符串集合 $A$，节点代表 $A$ 的一些子集的子串，边代表子集加入新的字符后可以转移到的子集。图上存在若干终止节点和一个初始节点。对于一个字符串，若其从初始节点开始，沿着图上的边转移，最终到达了一个终止节点，则证明该字符串属于 $A$，否则不属于。这个过程称为自动机对该串的识别。

重新定义一下 border：在多模式串匹配问题中，设模式串集合为 $A$，则 $A$ 中元素 $S$ 的一个前缀子串 $S_0$ 的 border 指的是 $S_0$ 的一个非自身后缀子串 $T_0$，满足 $T_0$ 是 $A$ 中任意一个元素的前缀子串。

也就是把 border 定义中是原串的前缀改为了是集合中任意一个串的前缀。

ACAM 比较特殊，每个节点对应了 $A$ 中某个字符串的一个前缀子串。这样就可以每个节点维护一个失配指针，指向该节点对应子串的最长 border。

考虑转移，一个节点的字符 $x$ 转移边应该转移到其加上字符 $x$ 后能转移到的最长的前缀子串。因此如果该节点对应字符串加上 $x$ 后也是前缀子串，则直接转移即可，否则将转移边指向失配指针的对应字符转移边即可。

显然除了根节点外，每个节点都有且仅有一个失配指针，且该指针指向的节点的对应字符串长度小于该节点的长度。因此失配指针构成了一棵树。很多时候需要维护这棵树上的一些信息。

## PAM

PAM 是可以识别原串的所有回文子串的自动机。

一个字符串的本质不同的回文子串只有 $O(n)$ 个。自动机上一个节点代表原串的本质相同的所有回文子串，转移边代表加入新字符以后生成的最长回文子串。显然自动机的节点数为 $O(n)$。

每个节点维护一个失配指针，指向该节点所代表的回文串的最长后缀回文子串。

构造 PAM 是 online 的。从前向后向 PAM 中插入字符串中的字符，维护一个指针为上一个字符插入后在自动机上匹配到的节点，那么新插入的字符只需要考虑该节点的所有后缀回文子串中长度最长的且加入新字符后仍然能构成回文串的那个。考虑要找到这个节点在 PAM 上不断跳 fail 即可。

考虑构建新节点的 fail 指针，只需要找到转移到新结点的那个节点的后缀回文子串中最长的且加入新字符后能构成回文串的，因此只需要继续跳 fail 指针找到第二个合法节点，该节点的对应字符转移边指向的节点即为新节点的失配节点。

特别的，PAM 有两个空节点，分别代表回文串长度为 $0$ 和为 $-1$ 的情况。其中长度为 $-1$ 的节点，其子节点就是各个长度为 $1$ 的回文串，对应对称轴为字符的串；而长度为 $0$ 的节点，其 fail 指针指向长度为 $-1$ 的串，该节点对应对称轴为两字符之间位置的字符串。

## SAM

SAM 是可以识别原串的所有后缀子串的自动机。

SAM 的一个节点代表一些后缀相同的子串（不一定是后缀子串），不同节点所代表的子串一定是本质不同的，但是一个节点所代表的所有子串不一定是本质相同的。事实上，SAM 可以看作原串一棵维护了所有后缀字串的 Trie 树经过压缩后得到的。每个节点维护一个信息 $len$，代表该节点代表的子串中最长的长度。当然还有另一个信息，代表最短的长度，但是这个信息可以通过 parent 树得到。每个节点都有一个集合，代表当前节点代表的子串在原串中出现位置的右端点的集合，称为 right 集合。

SAM 的失配指针指向的是该节点所代表的子串集合中最短的子串的非自身最长后缀子串所在的节点。显然失配指针对应的 right 集合完全包含了当前节点的 right 集合。特别的，我们称 SAM 的失配树为 parent 树。这棵树是其反串的后缀树，也即原串的前缀树。注意到父节点的最短子串长度一定是该节点的最长子串长度 $-1$。

可以证明，parent 树上任意两兄弟的 right 集合是无交的，且所有子节点 right 集合的并集即为父节点的 right 集合。因此在 parent 树上做树形 dp 即可维护出所有结点的 right 集合大小。

SAM 的构造方法也是 Online 的，具体而言，维护上一次插入结束以后新产生的最长后缀字串代表的节点 $last$，每次新插入一个节点代表新插入字符后形成的后缀子串。将 $last$ 以及其在 parent 树上没有新字符转移边的祖先的转移边指向新节点，对于最深的存在转移边的祖先 $p$，如果它转移边指向的节点 $q$ 的 right 集合为 $p$ 的 right 集合中所有数（除了上一次插入的位置） $+1$ 后得到的集合（可以通过 $len_q = len_p + 1$ 来快速判断），那么直接将新节点的失配指针指向 $q$ 即可。否则即意味着 $q$ 的 right 集合大小比 $p$ 的 right 集合大，注意到此时不能直接在 $q$ 出插入新的位置，我们需要再新建一个节点 $nq$，将 $nq$ 的 right 集合设为 $p$ 的 right 集合中的所有数字 $+1$ 得到的集合。显然 $q$ 是 $nq$ 的子集，因此 $q$ 的失配指针应该指向 $nq$ ，$p$ 的失配指针也应该指向 $nq$。而 $nq$ 和 $q$ 的转移边显然应该是完全相同的，因此直接拷贝即可。结束以后，需要将 $p$ 的祖先中所有指向 $q$ 的转移边都改为指向 $nq$。将新的后缀子串代表的节点的失配指针也指向 $nq$。

这个自动机的终止节点显然应该是插入新节点后代表新的最长后缀子串的节点。事实上，将 SAM 的终止节点设为除了根节点以外的所有节点，即可让这个自动机识别所有的子串。

## GSAM

广义后缀自动机。也就是多串的后缀自动机，可以识别其中任意串的后缀或子串。

GSAM 每个节点的各个信息的定义与 SAM 基本一致。

建立 GSAM 的方法两种，一种 ONLINE，一种 OFFLINE。

OFFLINE 的构造方法是，将所有主串建成一棵 Trie 树，然后在 Trie 树上进行 **BFS**，extend 一个节点时，将 last 指针设为其父节点在 GSAM 上对应的节点即可。

ONLINE 的构造方法是，每次插入一个串之前，将 last 指针设为 GSAM 的根节点，然后按照单串 SAM 的方法进行插入。在插入时需要特判两种情况（插入字符为 `x`，last 指针为 `u`：

1. `u->trans.count(x) && (u->trans[x]->len == (u->len + 1))`，也即本身就存在将要插入的字符串，那么不进行插入，直接返回 `u->trans[x]` 即可。
2. `u->trans.count(x) && (u->trans[x]->len != (u->len + 1))`。那么此时相当于直接在 fail 树内部插入一个代表该串的节点，容易发现这种情况类似于 SAM 中插入 nq 节点的情况。因此此时应该直接将新建出的 np 节点当作 nq 节点进行操作，而无需再新建 nq 节点。

